#!/usr/bin/env python3
"""
Rollout governance policies to repositories

This script deploys governance policies to repositories based on the manifest.
"""

import json
import os
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Any


def load_manifest(manifest_path: str) -> dict[str, Any]:
    """Load governance manifest."""
    with open(manifest_path) as f:
        import yaml
        return yaml.safe_load(f)


def get_github_token() -> str:
    """Get GitHub token from environment."""
    token = os.environ.get("GITHUB_TOKEN") or os.environ.get("GH_TOKEN")
    if not token:
        raise ValueError("GITHUB_TOKEN or GH_TOKEN environment variable is required")
    return token


def clone_repository(repo_name: str, work_dir: Path) -> Path:
    """Clone a repository."""
    repo_dir = work_dir / repo_name.replace("/", "_")
    
    if repo_dir.exists():
        print(f"  Repository already cloned at {repo_dir}")
        return repo_dir
    
    print(f"  Cloning {repo_name}...")
    
    # Use GitHub token for authentication if available
    token = os.environ.get("GITHUB_TOKEN") or os.environ.get("GH_TOKEN")
    if token:
        clone_url = f"https://x-access-token:{token}@github.com/{repo_name}.git"
    else:
        clone_url = f"https://github.com/{repo_name}.git"
    
    subprocess.run([
        "git", "clone",
        clone_url,
        str(repo_dir)
    ], check=True, capture_output=True)
    
    return repo_dir


def copy_workflow_files(source_dir: Path, repo_dir: Path, policies: list[str]) -> list[str]:
    """Copy workflow files based on policies."""
    copied = []
    workflows_dir = repo_dir / ".github" / "workflows"
    workflows_dir.mkdir(parents=True, exist_ok=True)
    
    if "thin-caller-ci" in policies:
        files = ["policy.yml", "reusable-policy.yml", "THIN-CALLER-POLICY.md"]
        
        for file in files:
            src = source_dir / ".github" / "workflows" / file
            dest = workflows_dir / file
            
            if src.exists():
                dest.write_text(src.read_text())
                copied.append(str(dest.relative_to(repo_dir)))
                print(f"    âœ“ Copied {file}")
    
    return copied


def create_rollout_commit(repo_dir: Path, copied_files: list[str]) -> bool:
    """Create a commit with the rollout changes."""
    os.chdir(repo_dir)
    
    # Check if there are changes
    result = subprocess.run(
        ["git", "status", "--porcelain"],
        capture_output=True,
        text=True
    )
    
    if not result.stdout.strip():
        print("    No changes to commit")
        return False
    
    # Stage files
    for file in copied_files:
        subprocess.run(["git", "add", file], check=True)
    
    # Create commit
    commit_msg = f"""Deploy governance policies

Automated rollout of governance policies:
- thin-caller-ci policy enforcement

Timestamp: {datetime.now(timezone.utc).isoformat()}
Generated by: governance rollout script
"""
    
    subprocess.run(["git", "commit", "-m", commit_msg], check=True)
    print("    âœ“ Created commit")
    return True


def create_rollout_pr(repo_dir: Path, repo_name: str) -> bool:
    """Create a pull request for the rollout."""
    os.chdir(repo_dir)
    
    # Create branch
    branch_name = f"governance/rollout-{datetime.now(timezone.utc).strftime('%Y%m%d')}"
    subprocess.run(["git", "checkout", "-b", branch_name], check=True)
    
    # Push branch
    subprocess.run(["git", "push", "-u", "origin", branch_name], check=True)
    
    # Create PR
    pr_title = "[Governance] Deploy autonomous governance policies"
    pr_body = """## Governance Rollout

This PR deploys the autonomous governance policies to this repository.

### Changes

- Add policy enforcement workflows
- Enable thin-caller CI policy
- Configure drift detection

### What This Means

The repository will now be under autonomous governance control:
- CI workflows will be validated for policy compliance
- Drift detection will run daily
- Automated fixes will be proposed when drift is detected

### Review Checklist

- [ ] Review the policy files
- [ ] Ensure existing workflows comply
- [ ] Verify branch protection settings

---

ðŸ¤– This PR was generated automatically by the governance rollout system.
"""
    
    subprocess.run([
        "gh", "pr", "create",
        "--title", pr_title,
        "--body", pr_body,
        "--label", "governance",
        "--label", "rollout"
    ], check=True)
    
    print("    âœ“ Created PR")
    return True


def rollout_to_repository(repo_config: dict[str, Any], source_dir: Path, work_dir: Path, dry_run: bool = False) -> dict[str, Any]:
    """Rollout governance to a single repository."""
    repo_name = repo_config["name"]
    policies = repo_config.get("policies", [])
    
    print(f"\nðŸ“¦ Rolling out to {repo_name}")
    print(f"   Policies: {', '.join(policies)}")
    
    if dry_run:
        print("   [DRY RUN] Skipping actual rollout")
        return {"repository": repo_name, "status": "dry_run", "success": True}
    
    try:
        # Clone repository
        repo_dir = clone_repository(repo_name, work_dir)
        
        # Copy workflow files
        copied_files = copy_workflow_files(source_dir, repo_dir, policies)
        
        if not copied_files:
            print("   No files to copy")
            return {"repository": repo_name, "status": "no_changes", "success": True}
        
        # Create commit
        if not create_rollout_commit(repo_dir, copied_files):
            return {"repository": repo_name, "status": "no_changes", "success": True}
        
        # Create PR
        create_rollout_pr(repo_dir, repo_name)
        
        return {"repository": repo_name, "status": "success", "success": True, "files": copied_files}
    
    except Exception as e:
        print(f"   âœ— Error: {e}")
        return {"repository": repo_name, "status": "error", "success": False, "error": str(e)}


def main():
    """CLI entry point."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Rollout governance policies")
    parser.add_argument("manifest", help="Path to governance manifest")
    parser.add_argument("--dry-run", action="store_true", help="Perform dry run without making changes")
    parser.add_argument("--work-dir", default="/tmp/governance-rollout", help="Working directory for cloning repos")
    
    args = parser.parse_args()
    
    print("Governance Policy Rollout")
    print("=" * 50)
    
    # Load manifest
    print(f"\nLoading manifest from {args.manifest}")
    manifest = load_manifest(args.manifest)
    
    source_dir = Path(".").resolve()
    work_dir = Path(args.work_dir)
    work_dir.mkdir(parents=True, exist_ok=True)
    
    governed_repos = manifest.get("governed_repositories", [])
    print(f"Found {len(governed_repos)} governed repositories")
    
    results = []
    
    for repo_config in governed_repos:
        # Skip control plane
        if repo_config["name"] == manifest["control_plane"]["repository"]:
            print(f"\nðŸ“¦ Skipping {repo_config['name']} (control plane)")
            continue
        
        result = rollout_to_repository(repo_config, source_dir, work_dir, args.dry_run)
        results.append(result)
    
    # Summary
    print("\n" + "=" * 50)
    print("Rollout Summary")
    print("=" * 50)
    
    success_count = sum(1 for r in results if r["success"])
    print(f"\nTotal: {len(results)}")
    print(f"Success: {success_count}")
    print(f"Failed: {len(results) - success_count}")
    
    for result in results:
        status_icon = "âœ“" if result["success"] else "âœ—"
        print(f"  {status_icon} {result['repository']}: {result['status']}")
    
    # Save results
    results_file = work_dir / "rollout-results.json"
    with open(results_file, "w") as f:
        json.dump({
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "results": results
        }, f, indent=2)
    
    print(f"\nResults saved to {results_file}")
    
    if success_count < len(results):
        sys.exit(1)


if __name__ == "__main__":
    main()
